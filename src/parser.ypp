
%{
#include "parser.h"

namespace {
static int yylex(void);
static void yyerror(char*);

const char* Text;
const char* TextBegin;
const char* TextEnd;
SyntaxTree* Tree;

boost::function< void(std::string, Node) > Callback;

	Node* add(const char* type, const Node& n) {
		Callback(type, n);
		return Tree->add(n);
	}
}

%}

%union {
	int	c;
	Node* node;
}

%token <c> CHAR

%type <node> regexp alt concat atom

%start regexp

%%

regexp: alt
	{
		$$ = add("regexp", Node(REGEXP, $1, 0, 0));
	}

alt:
	concat
|	alt '|' concat
	{
		$$ = add("alt", Node(ALTERNATION, $1, $3, 0));
	}
;

concat:
	atom
|	atom concat
	{
		$$ = add("concat", Node(CONCATENATION, $1, $2, 0));
	}
;

atom:
	CHAR
	{
		$$ = add("atom", Node(ATOM, 0, 0, $1));
	}
;

%%

namespace {	
	int yylex(void) {
		if (Text < TextEnd) {
			int c = *Text++;
			switch (c) {
				case 0:
					return -1;
				case '|':
					return '|';
				default:
					yylval.c = c;
					return CHAR;
			}
		}
		return -1;
	}

	void yyerror(char* msg) {
		THROW_RUNTIME_ERROR_WITH_OUTPUT(msg);
	}
}

bool parse(const std::string& text, SyntaxTree& tree, boost::function< void(std::string, Node) > callback) {
	Tree = &tree;
	Text = text.c_str();
	TextBegin = Text;
	TextEnd = Text + text.size();
	Callback = callback;
	int ret = yyparse();
  Text = 0;
	Tree = 0;
	return ret == 0 ? true: false;
}
