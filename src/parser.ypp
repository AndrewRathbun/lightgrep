
%{
#include "parser.h"
#include <cctype>
#include <iomanip>

namespace {
static int yylex(void);
static void yyerror(char*);

const unsigned char* Text;
const unsigned char* TextBegin;
const unsigned char* TextEnd;
SyntaxTree* Tree;

NodeHandler* Callback;

std::string MyTextLabel("");
std::stringstream MyBuf;

class Printer {
public:
	Printer(int i): Val(i) {}

	int Val;
};

std::ostream& operator<<(std::ostream&, const Printer&);

	Node* add(const char* type, const Node& n) {
		if (MyTextLabel.empty()) {
			MyTextLabel = type;
		}
		Callback->callback(MyTextLabel, n);
		MyTextLabel.clear();
		return Tree->add(n);
	}
}

%}

%union {
	unsigned int	c;
	Node* node;
}

%token <c> CHAR_TOKEN

%type <node> regexp alt concat rep atom literal charclass

%start regexp

%%

regexp: alt
	{
		$$ = add("regexp", Node(REGEXP, $1, 0, 0));
	}

alt:
	concat
|	alt '|' concat
	{
		$$ = add("alt", Node(ALTERNATION, $1, $3, 0));
	}
;

concat:
	rep
| concat rep
	{
		$$ = add("concat", Node(CONCATENATION, $1, $2, 0));
	}
;

rep:
	atom
| atom '*'
	{
		$$ = add("star", Node(STAR, $1, 0, 0));
	}
| atom '+'
	{
		$$ = add("plus", Node(PLUS, $1, 0, 0));
	}
|	atom '?'
	{
		$$ = add("question", Node(QUESTION, $1, 0, 0));
	}
;

atom:
	'(' alt ')'
	{
		$$ = add("group", Node(GROUP, $2, 0, 0));
	}
|	literal
;

literal:
	CHAR_TOKEN
	{
		$$ = add("literal", Node(LITERAL, 0, 0, $1));
	}
| '#'
	{
		Node n;
		n.Type = CHAR_CLASS;
		n.range('0', '9');
		$$ = add("class", n);
	}
|	'.'
	{
		$$ = add("dot", Node(DOT, 0, 0, '.'));
	}
	| '[' '^' charclass ']'
		{
			MyTextLabel = "^";
			MyTextLabel += MyBuf.str();
			MyBuf.str("");
			Node n;
			n.Type = CHAR_CLASS;
			n.Bits = ~$3->Bits;
			$$ = add("class", n);
		}
| '[' charclass ']'
	{
		MyTextLabel = MyBuf.str();
		MyBuf.str("");
		Node n;
		n.Type = CHAR_CLASS;
		n.Bits = $2->Bits;
		$$ = add("class", n);
	}
;

charclass:
	charclass '#' 
	{
		MyBuf << '#';
		$$ = add("ignore", Node(IGNORE, 0, 0, 0));
		$$->Bits = $1->Bits;
		$$->range('0', '9');
	}
| charclass CHAR_TOKEN '-' CHAR_TOKEN
	{
		MyBuf << Printer($2) << "-" << Printer($4);
		$$ = add("ignore", Node(IGNORE, 0, 0, 0));
		$$->Bits = $1->Bits;
		$$->range($2, $4);
	}
| charclass CHAR_TOKEN
	{
		MyBuf << Printer($2);
		$$ = add("ignore", Node(IGNORE, 0, 0, 0));
		$$->Bits = $1->Bits;
		$$->Bits.set($2);
	}
| CHAR_TOKEN '-' CHAR_TOKEN
	{
		MyBuf << Printer($1) << "-" << Printer($3);
		$$ = add("ignore", Node(IGNORE, 0, 0, 0));
		$$->Bits.reset();
		$$->range($1, $3);
	}
|	'#'
	{
		MyBuf << '#';
		$$ = add("ignore", Node(IGNORE, 0, 0, 0));
		$$->Bits.reset();
		$$->range('0', '9');
	}
|	CHAR_TOKEN
	{
		MyBuf << Printer($1);
		$$ = add("ignore", Node(IGNORE, 0, 0, $1));
	}
;

%%

namespace {
	int parseHexChar(unsigned int c) {
		int val = -1;
		if ('0' <= c && c <= '9') {
			val = (c - '0');
		}
		else if ('a' <= c && c <= 'f') {
			val = (c - 'a' + 10);
		}
		else if ('A' <= c && c <= 'F') {
			val = (c - 'A' + 10);
		}
		return val;
	}

	int consumeHexCode() {
		if (Text + 1 < TextEnd) {
			unsigned char one = *Text++,
					 					two = *Text++;
			int val = parseHexChar(one),
					ret;
			if (val < 0) {
				return val;
			}
			ret = val;
			ret <<= 4;
			val = parseHexChar(two);
			if (val < 0) {
				return val;
			}
			ret += val;
			yylval.c = ret;
			return CHAR_TOKEN;
		}
		return -1;
	}

	int consumeEscape() {
		if (Text >= TextEnd) {
			return -1;
		}
		unsigned int c = *Text++;
		switch (c) {
			case '|':
			case '(':
			case ')':
			case '?':
			case '+':
			case '*':
			case '.':
			case '#':
			case '[':
			case ']':
			case '^':
			case '-':
			case '\\':
				yylval.c = c;
				return CHAR_TOKEN;
			case 'n':
				yylval.c = '\n';
				return CHAR_TOKEN;
			case 'r':
				yylval.c = '\r';
				return CHAR_TOKEN;
			case 't':
				yylval.c = '\t';
				return CHAR_TOKEN;
			case 'x':
				return consumeHexCode();
		}
		return -1;
	}

	int yylex(void) {
		if (Text < TextEnd) {
			unsigned int c = *Text++;
			switch (c) {
				case 0:
					return -1;
				case '|':
				case '(':
				case ')':
				case '?':
				case '+':
				case '*':
				case '.':
				case '#':
				case '[':
				case ']':
				case '^':
				case '-':
					return c;
				case '\\':
					return consumeEscape();
				default:
					yylval.c = c;
					return CHAR_TOKEN;
			}
		}
		return -1;
	}

	void yyerror(char* msg) {
		THROW_RUNTIME_ERROR_WITH_OUTPUT(msg);
	}

	std::ostream& operator<<(std::ostream& out, const Printer& p) {
		if (std::isprint(p.Val)) {
			out << (char)p.Val;
		}
		else {
			out << "0x" << std::hex << std::setfill('0') << std::setw(2) << p.Val << std::dec;
		}
		return out;
	}
}

bool parse(const std::string& text, SyntaxTree& tree, NodeHandler& callback) {
	Tree = &tree;
	Text = (unsigned char*)text.c_str();
	TextBegin = Text;
	TextEnd = Text + text.size();
	Callback = &callback;
	int ret = yyparse();
  Text = 0;
	Tree = 0;
	return ret == 0 ? true: false;
}
