%{
#include "parsenode.h"
#include "parsetree.h"
#include "parseutil.h"
#include "pattern.h"
#include "unicode.h"

#include <string>
#include <vector>

namespace {
  static int yylex(void);
  static void yyerror(const char*);

  const int* Text;
  const int* TextBegin;
  const int* TextEnd;

  ParseTree* Tree;

  UnicodeSet USet;

  bool LiteralMode;
  bool CaseInsensitive;

/*
  template <class... Args>
  ParseNode* add(const char*, Args&&... args) {
    return Tree->add(args...);
  }
*/

  ParseNode* add(const ParseNode& n) {
    return Tree->add(n);
  }
}

%}

%union {
  unsigned int c;
  ParseNode* node;
  UnicodeSet* s;
}

%token <c> CHAR
%token <c> DIGIT
%token <c> BAD
%token <s> SET;

%type <node> regexp alt concat rep number atom literal charclass charclass_right cc_named
%type <c>    character cc_char cc_char_first cc_char_not_first

%start regexp

%%

regexp:
  alt
  {
    Tree->Root = $$ = add(ParseNode(ParseNode::REGEXP, $1));
  }

alt:
  concat
| alt '|' concat
  {
    $$ = add(ParseNode(ParseNode::ALTERNATION, $1, $3));
  }
;

concat:
  rep
| concat rep
  {
    $$ = add(ParseNode(ParseNode::CONCATENATION, $1, $2));
  }
;

rep:
  atom
| atom '*' '?'
  {
    $$ = add(ParseNode(ParseNode::REPETITION_NG, $1, 0, UNBOUNDED));
  }
| atom '+' '?'
  {
    $$ = add(ParseNode(ParseNode::REPETITION_NG, $1, 1, UNBOUNDED));
  }
| atom '?' '?'
  {
    $$ = add(ParseNode(ParseNode::REPETITION_NG, $1, 0, 1));
  }
| atom '{' number '}' '?'
  {
    $$ = add(ParseNode(ParseNode::REPETITION_NG, $1, $3->Val, $3->Val));
  }
| atom '{' number ',' '}' '?'
  {
    $$ = add(ParseNode(ParseNode::REPETITION_NG, $1, $3->Val, UNBOUNDED));
  }
| atom '{' number ',' number '}' '?'
  {
    if ($3->Val > $5->Val) {
      // {n,m} is ill-formed when n > m
      yyerror("syntax error");
    }
    else {
      $$ = add(ParseNode(ParseNode::REPETITION_NG, $1, $3->Val, $5->Val));
    }
  }
| atom '*'
  {
    $$ = add(ParseNode(ParseNode::REPETITION, $1, 0, UNBOUNDED));
  }
| atom '+'
  {
    $$ = add(ParseNode(ParseNode::REPETITION, $1, 1, UNBOUNDED));
  }
| atom '?'
  {
    $$ = add(ParseNode(ParseNode::REPETITION, $1, 0, 1));
  }
| atom '{' number '}'
  {
    $$ = add(ParseNode(ParseNode::REPETITION, $1, $3->Val, $3->Val));
  }
| atom '{' number ',' '}'
  {
    $$ = add(ParseNode(ParseNode::REPETITION, $1, $3->Val, UNBOUNDED));
  }
| atom '{' number ',' number '}'
  {
    if ($3->Val > $5->Val) {
      // {n,m} is ill-formed when n > m
      yyerror("syntax error");
    }
    else {
      $$ = add(ParseNode(ParseNode::REPETITION, $1, $3->Val, $5->Val));
    }
  }
;

number:
  DIGIT
  {
    $$ = add(ParseNode(ParseNode::TEMPORARY, $1 - 48));
  }
| number DIGIT
  {
    $$ = $1;
    $$->Val = $$->Val*10 + ($2 - 48);
  }
;

atom:
  '(' alt ')'
  {
    $$ = $2;
  }
| literal
;

literal:
  character
  {
    if (CaseInsensitive) {
      USet.reset();
      USet.set($1);
      if (caseDesensitize(USet)) {
        // TODO: Maybe handle the commmon ASCII case without going via USet?
        $$ = add(ParseNode(ParseNode::CHAR_CLASS, USet));
      }
      else {
        $$ = add(ParseNode(ParseNode::LITERAL, $1));
      }
    }
    else {
      $$ = add(ParseNode(ParseNode::LITERAL, $1));
    }
  }
| '.'
  {
    $$ = add(ParseNode(ParseNode::DOT, '.'));
  }
| '[' '^' charclass ']'
  {
    $$ = $3;

    // NB: PCRE applies case-insensitivity first, then negation. This is
    // important, as these two operations do not commute on a cc such as
    // [^a]. Let U be the set of all Unicode code points. Negating first
    // gives U / {a}, which becomes U again when closing under case-
    // insensitivity, due to A being a member of U / {a}, while closing
    // under case-insensitivity first gives {A, a}, which becomes
    // U / {A, a} after negation.

    if (CaseInsensitive) {
      caseDesensitize($$->Bits);
    }

    $$->Bits.flip();
  }
| '[' charclass ']'
  {
    $$ = $2;

    if (CaseInsensitive) {
      caseDesensitize($$->Bits);
    }
  }
| cc_named
  {
    if (CaseInsensitive) {
      caseDesensitize($$->Bits);
    }
  }
;

character:
  CHAR
| DIGIT
| ']'
  {
    $$ = ']';
  }
| '-'
  {
    $$ = '-';
  }
| '{'
  {
    $$ = '{';
  }
| '}'
  {
    $$ = '}';
  }
| ','
  {
    $$ = ',';
  }
;

charclass:
  cc_char_first '-' cc_char_not_first charclass_right
  {
    $$ = $4;
    $$->range($1, $3);
  }
| cc_char_first charclass_right
  {
    $$ = $2;
    $$->Bits.set($1);
  }
| cc_named charclass_right
  {
    $$ = $2;
    $$->Bits |= $1->Bits;
  }
;

charclass_right:
  cc_char_not_first '-' cc_char_not_first charclass_right
  {
    $$ = $4;
    $$->range($1, $3);
  }
| cc_char_not_first charclass_right
  {
    $$ = $2;
    $$->Bits.set($1);
  }
| cc_named charclass_right
  {
    $$ = $2;
    $$->Bits |= $1->Bits;
  }
| /* empty */
  {
    $$ = add(ParseNode(ParseNode::CHAR_CLASS, 'x'));
    $$->Bits['x'] = false;
  }
;

cc_char_first:
  ']'
  {
    $$ = ']';
  }
| cc_char
;

cc_char_not_first:
  '^'
  {
    $$ = '^';
  }
| cc_char
;

cc_char:
  CHAR
| DIGIT
| '-'
  {
    $$ = '-';
  }
| '|'
  {
    $$ = '|';
  }
| '('
  {
    $$ = '(';
  }
| ')'
  {
    $$ = ')';
  }
| '?'
  {
    $$ = '?';
  }
| '+'
  {
    $$ = '+';
  }
| '*'
  {
    $$ = '*';
  }
| '.'
  {
    $$ = '.';
  }
| '['
  {
    $$ = '[';
  }
| '{'
  {
    $$ = '{';
  }
| '}'
  {
    $$ = '}';
  }
| ','
  {
    $$ = ',';
  }
;

cc_named:
  SET
  {
    $$ = add(ParseNode(ParseNode::CHAR_CLASS, USet));
  }
;
%%

namespace {

  template <typename F>
  int consumeSingleton(F func) {
    const int val = func(Text, TextEnd);
    if (val < 0) {
      return BAD;
    }
    else {
      yylval.c = val;
      return CHAR;
    }
  }

  template <typename F>
  int consumeSet(F func) {
    const int val = func(Text, TextEnd, USet);
    if (val < 0) {
      return BAD;
    }
    else {
      yylval.s = &USet;
      return SET;
    }
  }

// FIXME: Add \c.
// FIXME: \b is not parsed correctly---should be backspace (0x08) inside
//  character classes, and a wordbreak assertion elsewhere.

  int consumeEscape() {
    if (Text >= TextEnd) {
      return BAD;
    }

    const int c = *Text++;
    switch (c) {
      // metacharacters as themselves
      case '|':
      case '(':
      case ')':
      case '?':
      case '+':
      case '*':
      case '.':
      case '[':
      case ']':
      case '^':
      case '-':
      case '{':
      case '}':
      case '\\':
        yylval.c = c;
        return CHAR;

      // ASCII escapes
      case 'a':
        yylval.c = '\a';
        return CHAR;
      case 'e':
        yylval.c = 0x1B;
        return CHAR;
      case 'f':
        yylval.c = '\f';
        return CHAR;
      case 'n':
        yylval.c = '\n';
        return CHAR;
      case 'r':
        yylval.c = '\r';
        return CHAR;
      case 't':
        yylval.c = '\t';
        return CHAR;

      // named character classes
      case 'd':
        USet.reset();
        USet.insert('0', '9' + 1);
        yylval.s = &USet;
        return SET;

      case 'D':
        USet.reset();
        USet.insert('0', '9' + 1);
        USet.flip();
        yylval.s = &USet;
        return SET;

      case 's':
        USet.reset();
        USet.set('\t');
        USet.set('\n');
        USet.set('\f');
        USet.set('\r');
        USet.set(' ');
        yylval.s = &USet;
        return SET;

      case 'S':
        USet.reset();
        USet.set('\t');
        USet.set('\n');
        USet.set('\f');
        USet.set('\r');
        USet.set(' ');
        USet.flip();
        yylval.s = &USet;
        return SET;

      case 'w':
        USet.reset();
        USet.insert('0', '9' + 1);
        USet.insert('A', 'Z' + 1);
        USet.set('_');
        USet.insert('a', 'z' + 1);
        yylval.s = &USet;
        return SET;

      case 'W':
        USet.reset();
        USet.insert('0', '9' + 1);
        USet.insert('A', 'Z' + 1);
        USet.set('_');
        USet.insert('a', 'z' + 1);
        USet.flip();
        yylval.s = &USet;
        return SET;

      // hexadecimal characters
      case 'x':
        return consumeSingleton(parseHex<const int*>);

      // octal characters
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
        --Text;
        return consumeSingleton(parseOct<const int*>);

      // named Unicode code points
      case 'N':
        return consumeSingleton(parseNamedCodePoint<const int*>);

      // Unicode properties
      case 'p':
      case 'P':
        Text -= 2;
        return consumeSet(parseProperty<const int*>);

      default:
        return BAD;
    }
  }

  int yylex(void) {
    if (Text < TextEnd) {
      const int c = *Text++;
      if (c < 1) {
        //   -1 indicates bogus UTF-8
        //    0 is a prohibited mid-string null byte
        return BAD;
      }
      else if (LiteralMode) {
        yylval.c = c;
        return CHAR;
      }
      else {
        switch (c) {
        case '|':
        case '(':
        case ')':
        case '?':
        case '+':
        case '*':
        case '.':
        case '[':
        case ']':
        case '^':
        case '-':
        case '{':
        case '}':
        case ',':
          return c;
        case '\\':
          return consumeEscape();
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          yylval.c = c;
          return DIGIT;
        default:
          yylval.c = c;
          return CHAR;
        }
      }
    }
    return -1;
  }

  void yyerror(const char* msg) {
    THROW_RUNTIME_ERROR_WITH_CLEAN_OUTPUT(
      msg << ", at offset " << (Text - TextBegin)
    );
  }
}

bool parse(const std::string& text, bool litMode,
           bool caseInsensitive, ParseTree& tree) {
  LiteralMode = litMode;
  CaseInsensitive = caseInsensitive;

  std::vector<int> cp;
  transform_utf8_to_unicode(text.begin(), text.end(), std::back_inserter(cp));

  TextBegin = Text = cp.data();
  TextEnd = Text + cp.size();

  Tree = &tree;
  Tree->init(cp.size());

  const int ret = yyparse();

  Text = 0;
  Tree = 0;
  return ret == 0;
}

bool parse(const Pattern& p, ParseTree& tree) {
  return parse(p.Expression, p.FixedString, p.CaseInsensitive, tree);
}

